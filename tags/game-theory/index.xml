<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Game-Theory on Luke Salamone&#39;s Blog</title>
    <link>https://lukesalamone.github.io/tags/game-theory/</link>
    <description>Recent content in Game-Theory on Luke Salamone&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 26 Nov 2022 20:25:13 -0800</lastBuildDate>
    <atom:link href="https://lukesalamone.github.io/tags/game-theory/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>My Favorite Antimaia Games</title>
      <link>https://lukesalamone.github.io/posts/best-antimaia-games/</link>
      <pubDate>Sat, 26 Nov 2022 20:25:13 -0800</pubDate>
      <guid>https://lukesalamone.github.io/posts/best-antimaia-games/</guid>
      <description>&lt;p&gt;This is a follow up to &lt;a href=&#34;../../posts/suboptimal-minimax/&#34;&gt;When Suboptimal Minimax is Better&lt;/a&gt;. After running 400 simulations, I can conclusively say that opponent modeling is pretty cool.&lt;/p&gt;&#xA;&lt;p&gt;The TLDR on opponent modeling is that if we have a pretty good idea of what the opponent might do, we can beat them faster by playing moves which aren&amp;rsquo;t objectively &amp;ldquo;optimal&amp;rdquo; as far as minimax is concerned. Here, Maia 1900 is a model of a relatively high-level chess player. Antimaia 1900 is specifically designed to counter Maia 1900.&lt;/p&gt;</description>
    </item>
    <item>
      <title>When Suboptimal Minimax is Better</title>
      <link>https://lukesalamone.github.io/posts/suboptimal-minimax/</link>
      <pubDate>Sat, 02 Jul 2022 16:24:10 -0500</pubDate>
      <guid>https://lukesalamone.github.io/posts/suboptimal-minimax/</guid>
      <description>&lt;script type=&#34;text/javascript&#34; async src=&#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML&#34;&gt;&lt;/script&gt;&#xA;&lt;script type=&#34;text/x-mathjax-config&#34;&gt;&#xA;MathJax.Hub.Config({&#xA;  tex2jax: {&#xA;    inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]],&#xA;    displayMath: [[&#39;$$&#39;,&#39;$$&#39;], [&#39;\[&#39;,&#39;\]&#39;]],&#xA;    processEscapes: true,&#xA;    processEnvironments: true,&#xA;    skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;],&#xA;    TeX: {&#xA;      equationNumbers: {&#xA;        autoNumber: &#34;AMS&#34;&#xA;      },&#xA;      extensions: [&#34;AMSmath.js&#34;, &#34;AMSsymbols.js&#34;]&#xA;    }&#xA;  }&#xA;});&#xA;&lt;/script&gt;&#xA;&lt;script type=&#34;text/x-mathjax-config&#34;&gt;&#xA;  MathJax.Hub.Queue(function() {&#xA;    var all = MathJax.Hub.getAllJax(), i;&#xA;    for(i = 0; i &lt; all.length; i += 1) {&#xA;        all[i].SourceElement().parentNode.className += &#39; has-jax&#39;;&#xA;    }&#xA;});&#xA;&lt;/script&gt;&#xA;&lt;p&gt;Minimax solves for optimal opponent play, minimizing the best move an opponent could make. But what if we knew the opponent wouldn&amp;rsquo;t make the best move? What if we knew what the opponent would do ahead of time? In that case, we could beat them faster by playing moves which take advantage of this fact, even if our move isn&amp;rsquo;t objectively the best move. &lt;a href=&#34;https://www.youtube.com/watch?v=XsdefZRavj4&#34;&gt;Don&amp;rsquo;t play the game, play the man.&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Alphabet Chess</title>
      <link>https://lukesalamone.github.io/posts/alphabet-chess/</link>
      <pubDate>Fri, 10 Jun 2022 23:56:14 -0500</pubDate>
      <guid>https://lukesalamone.github.io/posts/alphabet-chess/</guid>
      <description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;TLDR: Alphabet chess is a chess variant that allows handicapping by mixing in a bit of poker into the beginning of the game. Moves must be played according to a secret word at the beginning of the game.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;Chess has been played in different forms since the seventh century, and in its modern form since the nineteenth century. Opening theory, i.e. the study of the best moves to begin the game with, has been developing since then.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Creating an AI for Gomoku</title>
      <link>https://lukesalamone.github.io/posts/gomoku2049/</link>
      <pubDate>Tue, 19 May 2020 14:28:57 +0800</pubDate>
      <guid>https://lukesalamone.github.io/posts/gomoku2049/</guid>
      <description>&lt;p&gt;Gomoku is a strategy game similar to tic tac toe, but played on a larger board and with the goal of getting 5 in a row rather than 3. Since the game has perfect information and has simple rules, I thought it would be a fun exercise in creating a game AI.&#xA;In February 2020 I decided to code up Gomoku2049. The game is a demonstration of MiniMax, which is an algorithm for finding the move which minimizes the opponent’s best moves. This article is an overview of the game’s technical highlights.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
